{{- if and .Values.autoscalerVm.enabled .Values.composeYaml }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "vela.autoscaler.composeConfigName" . }}
  labels:
    {{- include "vela.labels" . | nindent 4 }}
data:
  vector.yml: |
{{- .Values.vectorYaml | nindent 4 }}
  postgresql.conf: |-
{{- .Values.postgresqlConf | nindent 4 }}
  docker-compose.yml: |
{{- .Values.composeYaml | nindent 4 }}
  pg_hba.conf: |-
{{- .Values.pgHbaConf | nindent 4 }}
  {{- if .Values.pgbouncer.enabled }}
  {{- $dbPassword := required "Values.secret.db.password is required when PgBouncer is enabled" .Values.secret.db.password }}
  {{- $pgbouncerAdminPassword := required "Values.secret.pgbouncer.admin_password is required when PgBouncer is enabled" .Values.secret.pgbouncer.admin_password }}
  {{- $pgbouncerConfig := .Values.pgbouncer.config | default (dict) }}
  namespace: {{ .Release.Namespace }}
  pgbouncer.ini: |
    [databases]
    postgres = host=db port=5432 user=postgres password={{ $dbPassword | quote }}

    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 5432
    auth_type = plain
    auth_file = /etc/pgbouncer/users.txt
    pool_mode = transaction
    max_client_conn = {{ $pgbouncerConfig.max_client_conn | default 100 }}
    default_pool_size = {{ $pgbouncerConfig.default_pool_size | default 20 }}
    reserve_pool_size = {{ $pgbouncerConfig.reserve_pool_size | default 0 }}
    query_wait_timeout = {{ $pgbouncerConfig.query_wait_timeout | default 30 }}
    server_idle_timeout = {{ $pgbouncerConfig.server_idle_timeout | default 60 }}
    server_lifetime = {{ $pgbouncerConfig.server_lifetime | default 600 }}
    ignore_startup_parameters = extra_float_digits
    log_connections = 1
    log_disconnections = 1
    admin_users = pgbouncer_admin
    stats_users = pgbouncer_admin
  pgbouncer_pg18.ini: |
    [databases]
    postgres = host=db port=5432 user=postgres password={{ $dbPassword | quote }}

    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    unix_socket_dir =
    auth_type = plain
    auth_file = /vela/config/users.txt
    pool_mode = transaction
    max_client_conn = {{ $pgbouncerConfig.max_client_conn | default 100 }}
    default_pool_size = {{ $pgbouncerConfig.default_pool_size | default 20 }}
    reserve_pool_size = {{ $pgbouncerConfig.reserve_pool_size | default 0 }}
    query_wait_timeout = {{ $pgbouncerConfig.query_wait_timeout | default 30 }}
    server_idle_timeout = {{ $pgbouncerConfig.server_idle_timeout | default 60 }}
    server_lifetime = {{ $pgbouncerConfig.server_lifetime | default 600 }}
    log_connections = 1
    log_disconnections = 1
    admin_users = pgbouncer_admin
    stats_users = pgbouncer_admin
    ignore_startup_parameters = extra_float_digits
  users.txt: |
    "postgres" {{ $dbPassword | quote }}
    "pgbouncer_admin" {{ $pgbouncerAdminPassword | quote }}
  {{- end }}
{{- end }}
---
kind: ConfigMap
metadata:
  name: migrations
  labels:
    {{- include "vela.labels" . | nindent 4 }}
apiVersion: v1
data:
  00000000000000-schema.sql: |-
    -- migrate:up
    CREATE USER postgres;
    CREATE USER pgbouncer;

    REVOKE ALL PRIVILEGES ON SCHEMA public FROM pgbouncer;

    CREATE SCHEMA pgbouncer AUTHORIZATION pgbouncer;

    CREATE OR REPLACE FUNCTION pgbouncer.get_auth(p_usename TEXT)
    RETURNS TABLE(username TEXT, password TEXT) AS
    $$
    BEGIN
        RAISE WARNING 'PgBouncer auth request: %', p_usename;

    RETURN QUERY
    SELECT usename::TEXT, passwd::TEXT FROM pg_catalog.pg_shadow
    WHERE usename = p_usename;
    END;
    $$ LANGUAGE plpgsql SECURITY DEFINER;

    REVOKE ALL ON FUNCTION pgbouncer.get_auth(p_usename TEXT) FROM PUBLIC;
    GRANT EXECUTE ON FUNCTION pgbouncer.get_auth(p_usename TEXT) TO pgbouncer;
    -- migrate:down

  00000000000001-initial-schema.sql: |-
    -- migrate:up

    -- Set up realtime
    -- defaults to empty publication
    create publication supabase_realtime;

    -- Vela super admin
    create user supabase_admin;
    alter user  supabase_admin with superuser createdb createrole replication bypassrls;

    -- Vela replication user
    create user supabase_replication_admin with login replication;

    -- Vela read-only user
    create role supabase_read_only_user with login bypassrls;
    grant pg_read_all_data to supabase_read_only_user;

    -- Extension namespacing
    create schema if not exists extensions;
    create extension if not exists pgcrypto         with schema extensions;
    create extension if not exists pgjwt            with schema extensions;
    create extension if not exists "uuid-ossp"      with schema extensions;

    -- Set up auth roles for the developer
    create role anon                nologin noinherit;
    create role authenticated       nologin noinherit; -- "logged in" user: web_user, app_user, etc
    create role service_role        nologin noinherit bypassrls; -- allow developers to create JWT's that bypass their policies

    create user authenticator noinherit;
    grant anon              to authenticator;
    grant authenticated     to authenticator;
    grant service_role      to authenticator;
    grant supabase_admin    to authenticator;

    grant usage                     on schema public to postgres, anon, authenticated, service_role;
    alter default privileges in schema public grant all on tables to postgres, anon, authenticated, service_role;
    alter default privileges in schema public grant all on functions to postgres, anon, authenticated, service_role;
    alter default privileges in schema public grant all on sequences to postgres, anon, authenticated, service_role;

    -- Allow Extensions to be used in the API
    grant usage                     on schema extensions to postgres, anon, authenticated, service_role;

    -- Set up namespacing
    alter user supabase_admin SET search_path TO public, extensions;

    -- These are required so that the users receive grants whenever "supabase_admin" creates tables/function
    alter default privileges for user supabase_admin in schema public grant all
        on sequences to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema public grant all
        on tables to postgres, anon, authenticated, service_role;
    alter default privileges for user supabase_admin in schema public grant all
        on functions to postgres, anon, authenticated, service_role;

    -- Set short statement/query timeouts for API roles
    alter role anon set statement_timeout = '3s';
    alter role authenticated set statement_timeout = '8s';

    -- migrate:down

  00000000000002-storage-schema.sql: |-
    -- migrate:up

    CREATE SCHEMA IF NOT EXISTS storage AUTHORIZATION supabase_admin;

    grant usage on schema storage to postgres, anon, authenticated, service_role;
    alter default privileges in schema storage grant all on tables to postgres, anon, authenticated, service_role;
    alter default privileges in schema storage grant all on functions to postgres, anon, authenticated, service_role;
    alter default privileges in schema storage grant all on sequences to postgres, anon, authenticated, service_role;

    CREATE TABLE "storage"."buckets" (
                                         "id" text not NULL,
                                         "name" text NOT NULL,
                                         "owner" uuid,
                                         "created_at" timestamptz DEFAULT now(),
                                         "updated_at" timestamptz DEFAULT now(),
                                         PRIMARY KEY ("id")
    );
    CREATE UNIQUE INDEX "bname" ON "storage"."buckets" USING BTREE ("name");

    CREATE TABLE "storage"."objects" (
                                         "id" uuid NOT NULL DEFAULT extensions.uuid_generate_v4(),
                                         "bucket_id" text,
                                         "name" text,
                                         "owner" uuid,
                                         "created_at" timestamptz DEFAULT now(),
                                         "updated_at" timestamptz DEFAULT now(),
                                         "last_accessed_at" timestamptz DEFAULT now(),
                                         "metadata" jsonb,
                                         CONSTRAINT "objects_bucketId_fkey" FOREIGN KEY ("bucket_id") REFERENCES "storage"."buckets"("id"),
                                         PRIMARY KEY ("id")
    );
    CREATE UNIQUE INDEX "bucketid_objname" ON "storage"."objects" USING BTREE ("bucket_id","name");
    CREATE INDEX name_prefix_search ON storage.objects(name text_pattern_ops);

    ALTER TABLE storage.objects ENABLE ROW LEVEL SECURITY;

    CREATE FUNCTION storage.foldername(name text)
        RETURNS text[]
     LANGUAGE plpgsql
    AS $function$
    DECLARE
    _parts text[];
    BEGIN
    select string_to_array(name, '/') into _parts;
    return _parts[1:array_length(_parts,1)-1];
    END
    $function$;

    CREATE FUNCTION storage.filename(name text)
        RETURNS text
        LANGUAGE plpgsql
    AS $function$
    DECLARE
    _parts text[];
    BEGIN
    select string_to_array(name, '/') into _parts;
    return _parts[array_length(_parts,1)];
    END
    $function$;

    CREATE FUNCTION storage.extension(name text)
        RETURNS text
        LANGUAGE plpgsql
    AS $function$
    DECLARE
    _parts text[];
    _filename text;
    BEGIN
    select string_to_array(name, '/') into _parts;
    select _parts[array_length(_parts,1)] into _filename;
    -- @todo return the last part instead of 2
    return split_part(_filename, '.', 2);
    END
    $function$;

    CREATE FUNCTION storage.search(prefix text, bucketname text, limits int DEFAULT 100, levels int DEFAULT 1, offsets int DEFAULT 0)
        RETURNS TABLE (
                          name text,
                          id uuid,
                          updated_at TIMESTAMPTZ,
                          created_at TIMESTAMPTZ,
                          last_accessed_at TIMESTAMPTZ,
                          metadata jsonb
                      )
        LANGUAGE plpgsql
    AS $function$
    DECLARE
    _bucketId text;
    BEGIN
        -- will be replaced by migrations when server starts
        -- saving space for cloud-init
    END
    $function$;

    -- create migrations table
    -- https://github.com/ThomWright/postgres-migrations/blob/master/src/migrations/0_create-migrations-table.sql
    -- we add this table here and not let it be auto-created so that the permissions are properly applied to it
    CREATE TABLE IF NOT EXISTS storage.migrations (
                                                      id integer PRIMARY KEY,
                                                      name varchar(100) UNIQUE NOT NULL,
        hash varchar(40) NOT NULL, -- sha1 hex encoded hash of the file name and contents, to ensure it hasn't been altered since applying the migration
        executed_at timestamp DEFAULT current_timestamp
        );

    CREATE USER supabase_storage_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    GRANT ALL PRIVILEGES ON SCHEMA storage TO supabase_storage_admin;
    GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA storage TO supabase_storage_admin;
    GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA storage TO supabase_storage_admin;
    ALTER USER supabase_storage_admin SET search_path = "storage";
    ALTER table "storage".objects owner to supabase_storage_admin;
    ALTER table "storage".buckets owner to supabase_storage_admin;
    ALTER table "storage".migrations OWNER TO supabase_storage_admin;
    ALTER function "storage".foldername(text) owner to supabase_storage_admin;
    ALTER function "storage".filename(text) owner to supabase_storage_admin;
    ALTER function "storage".extension(text) owner to supabase_storage_admin;
    ALTER function "storage".search(text,text,int,int,int) owner to supabase_storage_admin;

    -- migrate:down
  00000000000003-post-setup.sql: |-
    -- migrate:up

    ALTER ROLE supabase_admin SET search_path TO "\$user",public,extensions;
    ALTER ROLE postgres SET search_path TO "\$user",public,extensions;

    -- Trigger for pg_cron
    CREATE OR REPLACE FUNCTION extensions.grant_pg_cron_access()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
    DECLARE
    schema_is_cron bool;
    BEGIN
      schema_is_cron = (
        SELECT n.nspname = 'cron'
        FROM pg_event_trigger_ddl_commands() AS ev
        LEFT JOIN pg_catalog.pg_namespace AS n
          ON ev.objid = n.oid
      );

      IF schema_is_cron
      THEN
        grant usage on schema cron to postgres with grant option;

        alter default privileges in schema cron grant all on tables to postgres with grant option;
        alter default privileges in schema cron grant all on functions to postgres with grant option;
        alter default privileges in schema cron grant all on sequences to postgres with grant option;

        alter default privileges for user supabase_admin in schema cron grant all
            on sequences to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on tables to postgres with grant option;
        alter default privileges for user supabase_admin in schema cron grant all
            on functions to postgres with grant option;

        grant all privileges on all tables in schema cron to postgres with grant option;

    END IF;

    END;
    $$;
    CREATE EVENT TRIGGER issue_pg_cron_access ON ddl_command_end WHEN TAG in ('CREATE SCHEMA')
    EXECUTE PROCEDURE extensions.grant_pg_cron_access();
    COMMENT ON FUNCTION extensions.grant_pg_cron_access IS 'Grants access to pg_cron';

    -- Event trigger for pg_net
    CREATE OR REPLACE FUNCTION extensions.grant_pg_net_access()
    RETURNS event_trigger
    LANGUAGE plpgsql
    AS $$
    BEGIN
      IF EXISTS (
        SELECT 1
        FROM pg_event_trigger_ddl_commands() AS ev
        JOIN pg_extension AS ext
        ON ev.objid = ext.oid
        WHERE ext.extname = 'pg_net'
      )
      THEN
        IF NOT EXISTS (
          SELECT 1
          FROM pg_roles
          WHERE rolname = 'supabase_functions_admin'
        )
        THEN
          CREATE USER supabase_functions_admin NOINHERIT CREATEROLE LOGIN NOREPLICATION;
    END IF;

        GRANT USAGE ON SCHEMA net TO supabase_functions_admin, postgres, anon, authenticated, service_role;

    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;
    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SECURITY DEFINER;

    ALTER function net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;
    ALTER function net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) SET search_path = net;

    REVOKE ALL ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;
    REVOKE ALL ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) FROM PUBLIC;

    GRANT EXECUTE ON FUNCTION net.http_get(url text, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
        GRANT EXECUTE ON FUNCTION net.http_post(url text, body jsonb, params jsonb, headers jsonb, timeout_milliseconds integer) TO supabase_functions_admin, postgres, anon, authenticated, service_role;
    END IF;
    END;
    $$;
    COMMENT ON FUNCTION extensions.grant_pg_net_access IS 'Grants access to pg_net';

    DO
    $$
    BEGIN
      IF NOT EXISTS (
        SELECT 1
        FROM pg_event_trigger
        WHERE evtname = 'issue_pg_net_access'
      ) THEN
        CREATE EVENT TRIGGER issue_pg_net_access
        ON ddl_command_end
        WHEN TAG IN ('CREATE EXTENSION')
        EXECUTE PROCEDURE extensions.grant_pg_net_access();
    END IF;
    END
    $$;

    -- Supabase dashboard user
    CREATE ROLE dashboard_user NOSUPERUSER CREATEDB CREATEROLE REPLICATION;
    GRANT ALL ON DATABASE postgres TO dashboard_user;
    GRANT ALL ON SCHEMA extensions TO dashboard_user;
    GRANT ALL ON SCHEMA storage TO dashboard_user;
    GRANT ALL ON ALL TABLES IN SCHEMA extensions TO dashboard_user;
    -- GRANT ALL ON ALL TABLES IN SCHEMA storage TO dashboard_user;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO dashboard_user;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA extensions TO dashboard_user;
    GRANT ALL ON ALL ROUTINES IN SCHEMA storage TO dashboard_user;
    GRANT ALL ON ALL ROUTINES IN SCHEMA extensions TO dashboard_user;

    -- migrate:down

  00000000000004-extension.sql: |-
    -- migrate:up
    CREATE SCHEMA IF NOT exists extensions;
    CREATE EXTENSION IF NOT EXISTS pg_stat_statements with schema extensions;
    -- migrate:down

  10000000000000_demote-postgres.sql: |-
    -- migrate:up

    -- demote postgres user
    GRANT ALL ON DATABASE postgres TO postgres;
    GRANT ALL ON SCHEMA public TO postgres;
    GRANT ALL ON SCHEMA storage TO postgres;
    GRANT ALL ON SCHEMA extensions TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA public TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL TABLES IN SCHEMA extensions TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA public TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL SEQUENCES IN SCHEMA extensions TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA public TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA storage TO postgres;
    GRANT ALL ON ALL ROUTINES IN SCHEMA extensions TO postgres;
    ALTER ROLE postgres NOSUPERUSER CREATEDB CREATEROLE LOGIN REPLICATION BYPASSRLS;

    -- migrate:down
