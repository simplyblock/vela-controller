{{- if and .Values.vector.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: vela-vector-config
  labels:
    app.kubernetes.io/name: vela
    app.kubernetes.io/instance: {{ .Release.Name }}
    vector.dev/exclude: "true"
data:
  vector.yml: |
    api:
      enabled: true
      address: 0.0.0.0:9001

    sources:
      kubernetes_host:
        type: kubernetes_logs

    transforms:
      global_logs:
        type: remap
        inputs:
          - kubernetes_host
        source: |-
          .database_label = del(.kubernetes.pod_labels."stackgres.io/cluster-name")
          map_keys(., recursive: true) -> |key| { replace(key, ".", "_") }
          .event_message = del(.message)
          .appname = del(.kubernetes.container_name)
          .metadata.id = uuid_v7()
          del(.file)
          del(.kubernetes)
          del(.source_type)
          del(.stream)
      router:
        type: route
        inputs:
          - global_logs
        route:
          kong: '.appname == "vela-kong"'
          auth: '.appname == "vela-auth"'
          controller: '.appname == "vela-controller"'
          studio: '.appname == "vela-studio"'
          db: '.database_label == "database"'

      # Ignores non nginx errors since they are related with kong booting up
      kong_logs:
        type: remap
        inputs:
          - router.kong
        source: |-
          req, err = parse_nginx_log(.event_message, "combined")
          if err == null {
              .timestamp = req.timestamp
              .level = "info"
              .metadata.request.headers.referer = req.referer
              .metadata.request.headers.user_agent = req.agent
              .metadata.request.headers.cf_connecting_ip = req.client
              .metadata.request.method = req.method
              .metadata.request.path = req.path
              .metadata.request.protocol = req.protocol
              .metadata.response.status_code = req.status
          }
          if err != null {
            abort
          }

      # Ignores non nginx errors since they are related with kong booting up
      kong_err:
        type: remap
        inputs:
          - router.kong
        source: |-
          .metadata.request.method = "GET"
          .metadata.response.status_code = 200
          parsed, err = parse_nginx_log(.event_message, "error")
          if err == null {
              .timestamp = parsed.timestamp
              .level = parsed.severity
              .metadata.request.host = parsed.host
              .metadata.request.headers.cf_connecting_ip = parsed.client
              url, err = split(parsed.request, " ")
              if err == null {
                  .metadata.request.method = url[0]
                  .metadata.request.path = url[1]
                  .metadata.request.protocol = url[2]
              }
          }
          if err != null {
            abort
          }

      auth_logs:
        type: remap
        inputs:
          - router.auth
        source: |-
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+-\d+-\d+ \d+:\d+:\d+[.,]\d+) (?P<level>\w+)\s+(?:\[(?P<logger>[^\]]+)\]\s+\((?P<thread>[^)]+)\)\s+)?(?P<msg>.*)$', numeric_groups: true)
          if err == null {
              .event_message = parsed.msg
              .timestamp = timestamp!(parsed.time)
              .level = "info"
              if exists(parsed.level) {
                  .level = parsed.level
              }
          }

      controller_logs:
        type: remap
        inputs:
          - router.controller
        source: |-
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+-\d+-\d+T\d+:\d+:\d+([+|-]\d{2}:?\d{2})|Z)\W+(?P<level>\w+)\W+(?P<msg>.*)$', numeric_groups: true)
          if err == null {
              .event_message = parsed.msg
              .timestamp = now()
              if exists(parsed.time) {
                  .timestamp = timestamp!(parsed.time)
              }
              .level = "info"
              if exists(parsed.level) {
                  .level = parsed.level
              }
          }

      studio_logs:
        type: remap
        inputs:
          - router.studio
        source: |-
          .level = "info"
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+:\d+:\d+\.\d+) \[(?P<level>\w+)\] (?P<msg>.*)$')
          if err == null {
              .event_message = parsed.msg
              .timestamp = timestamp!(parsed.time)
              .level = parsed.level
          }

      db_logs:
        type: remap
        inputs:
          - router.db
        source: |-
          .level = "info"
          .timestamp = now()
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+-\d+-\d+ \d+:\d+:\d+(,\d+| UTC))\s+(?:\[\d+\]:\s+.*?\s+)?(?P<level>\w+):\s+(?P<msg>.*)$', numeric_groups: true)
          if err == null {
              .event_message = parsed.msg
              .timestamp = timestamp!(parsed.time)
              if exists(parsed.level) {
                  .level = parsed.level
              }
          }
          del(.database_label)

    sinks:
      loki:
        type: 'loki'
        inputs:
          - db_logs
          - studio_logs
          - controller_logs
          - auth_logs
        endpoint: 'http://{{ .Values.loki.name }}.{{ .Values.loki.namespace }}.svc.cluster.local:3100'
        labels:
          region: 'global'
          level: '{{ "{{" }} .metadata.parsed.error_severity {{ "}}" }}'
          appname: '{{ "{{" }} .appname {{ "}}" }}'
        encoding:
          codec: json
{{- end }}
