{{- if and .Values.vector.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: vela-vector-config
  labels:
    app.kubernetes.io/name: vela
    app.kubernetes.io/instance: {{ .Release.Name }}
    vector.dev/exclude: "true"
data:
  vector.yml: |
    api:
      enabled: true
      address: 0.0.0.0:9001

    sources:
      kubernetes_host:
        type: kubernetes_logs

    transforms:
      project_logs:
        type: remap
        inputs:
          - kubernetes_host
        source: |-
          . = map_keys(., recursive: true) -> |key| { replace(key, ".", "_") }
          .project = "global"
          .event_message = del(.message)
          .appname = del(.kubernetes.container_name)
          .metadata.id = uuid_v7()
          log(.kubernetes.pod_labels)
          .database_label = del(.kubernetes.pod_labels."stackgres_io/cluster-name")
          del(.file)
          del(.kubernetes)
          del(.source_type)
          del(.stream)
      router:
        type: route
        inputs:
          - project_logs
        route:
          kong: '.appname == "vela-kong"'
          auth: '.appname == "vela-auth"'
          controller: '.appname == "vela-controller"'
          studio: '.appname == "vela-studio"'
          db: '.database_label == "database"'
      # Ignores non nginx errors since they are related with kong booting up
      kong_logs:
        type: remap
        inputs:
          - router.kong
        source: |-
          req, err = parse_nginx_log(.event_message, "combined")
          if err == null {
              .timestamp = req.timestamp
              .metadata.request.headers.referer = req.referer
              .metadata.request.headers.user_agent = req.agent
              .metadata.request.headers.cf_connecting_ip = req.client
              .metadata.request.method = req.method
              .metadata.request.path = req.path
              .metadata.request.protocol = req.protocol
              .metadata.response.status_code = req.status
          }
          if err != null {
            abort
          }
      # Ignores non nginx errors since they are related with kong booting up
      kong_err:
        type: remap
        inputs:
          - router.kong
        source: |-
          .metadata.request.method = "GET"
          .metadata.response.status_code = 200
          parsed, err = parse_nginx_log(.event_message, "error")
          if err == null {
              .timestamp = parsed.timestamp
              .severity = parsed.severity
              .metadata.request.host = parsed.host
              .metadata.request.headers.cf_connecting_ip = parsed.client
              url, err = split(parsed.request, " ")
              if err == null {
                  .metadata.request.method = url[0]
                  .metadata.request.path = url[1]
                  .metadata.request.protocol = url[2]
              }
          }
          if err != null {
            abort
          }
      auth_logs:
        type: remap
        inputs:
          - router.auth
        source: |-
          parsed, err = parse_json(.event_message)
          if err == null {
              .metadata.timestamp = parsed.time
              .metadata = merge!(.metadata, parsed)
          }

      controller_logs:
        type: remap
        inputs:
          - router.controller
        source: |-
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+-\d+-\d+ \d+:\d+:\d+)? ?(?P<level>INFO|NOTICE|WARNING|ERROR|LOG|FATAL|PANIC?):? .*$', numeric_groups: true)
          if err == null {
              .event_message = parsed.msg
              .timestamp = now()
              if exists(parsed.time) {
                  .timestamp = timestamp!(parsed.time)
              }
              .metadata.parsed.error_severity = "info"
              if  {
                  .metadata.parsed.error_severity = parsed.level
              }
              .metadata.host = .project
          }
      studio_logs:
        type: remap
        inputs:
          - router.studio
        source: |-
          .metadata.project = del(.project)
          .metadata.external_id = .metadata.project
          parsed, err = parse_regex(.event_message, r'^(?P<time>\d+:\d+:\d+\.\d+) \[(?P<level>\w+)\] (?P<msg>.*)$')
          if err == null {
              .event_message = parsed.msg
              .metadata.level = parsed.level
          }
          .metadata.parsed.error_severity = "info"
          if exists(parsed.level) {
            .metadata.parsed.error_severity = parsed.level
          }
          .metadata.response.status_code = ""
          .metadata.request.method = ""
          .metadata.request.path = ""
      # Postgres logs some messages to stderr which we map to warning severity level
      db_logs:
        type: remap
        inputs:
          - router.db
        source: |-
          .metadata.host = "db-global"
          .metadata.parsed.timestamp = .timestamp
          
          parsed, err = parse_regex(.event_message, r'.*(?P<level>INFO|NOTICE|WARNING|ERROR|LOG|FATAL|PANIC?):.*', numeric_groups: true)

          if err != null || parsed == null {
            .metadata.parsed.error_severity = "info"
          }
          if parsed != null {
          .metadata.parsed.error_severity = parsed.level
          }
          if .metadata.parsed.error_severity == "info" {
              .metadata.parsed.error_severity = "log"
          }
          .metadata.parsed.error_severity = upcase!(.metadata.parsed.error_severity)
          .metadata.response.status_code = ""
          .metadata.request.method = ""
          .metadata.request.path = ""

    sinks:
      loki:
        type: 'loki'
        inputs:
          - db_logs
          - studio_logs
          - controller_logs
        endpoint: 'http://loki.loki.svc.cluster.local:3100'
        labels:
          region: 'global'
          level: '{{ "{{" }} .metadata.parsed.error_severity {{ "}}" }}'
          appname: '{{ "{{" }} .appname {{ "}}" }}'
          status: '{{ "{{" }} .metadata.response.status_code {{ "}}" }}'
          method: '{{ "{{" }} .metadata.request.method {{ "}}" }}'
          path: '{{ "{{" }} .metadata.request.path {{ "}}" }}'
        encoding:
          codec: json
{{- end }}
